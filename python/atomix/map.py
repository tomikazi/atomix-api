# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: atomix/map/map.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import AsyncGenerator, Optional

import betterproto
import grpclib

from .atomix import headers


class ResponseStatus(betterproto.Enum):
    OK = 0
    NOOP = 1
    WRITE_LOCK = 2
    PRECONDITION_FAILED = 3


class EventResponseType(betterproto.Enum):
    NONE = 0
    INSERTED = 1
    UPDATED = 2
    REMOVED = 3


@dataclass
class CreateRequest(betterproto.Message):
    header: headers.RequestHeader = betterproto.message_field(1)


@dataclass
class CreateResponse(betterproto.Message):
    header: headers.ResponseHeader = betterproto.message_field(1)


@dataclass
class CloseRequest(betterproto.Message):
    header: headers.RequestHeader = betterproto.message_field(1)
    delete: bool = betterproto.bool_field(2)


@dataclass
class CloseResponse(betterproto.Message):
    header: headers.ResponseHeader = betterproto.message_field(1)


@dataclass
class ExistsRequest(betterproto.Message):
    header: headers.RequestHeader = betterproto.message_field(1)
    key: str = betterproto.string_field(2)


@dataclass
class ExistsResponse(betterproto.Message):
    header: headers.ResponseHeader = betterproto.message_field(1)
    contains_key: bool = betterproto.bool_field(2)


@dataclass
class SizeRequest(betterproto.Message):
    header: headers.RequestHeader = betterproto.message_field(1)


@dataclass
class SizeResponse(betterproto.Message):
    header: headers.ResponseHeader = betterproto.message_field(1)
    size: int = betterproto.uint32_field(2)


@dataclass
class PutRequest(betterproto.Message):
    header: headers.RequestHeader = betterproto.message_field(1)
    key: str = betterproto.string_field(2)
    value: bytes = betterproto.bytes_field(3)
    version: int = betterproto.uint64_field(4)
    if_empty: bool = betterproto.bool_field(6)
    ttl: timedelta = betterproto.message_field(5)


@dataclass
class PutResponse(betterproto.Message):
    header: headers.ResponseHeader = betterproto.message_field(1)
    status: "ResponseStatus" = betterproto.enum_field(2)
    created: datetime = betterproto.message_field(3)
    updated: datetime = betterproto.message_field(4)
    previous_value: bytes = betterproto.bytes_field(5)
    previous_version: int = betterproto.uint64_field(6)


@dataclass
class ReplaceRequest(betterproto.Message):
    header: headers.RequestHeader = betterproto.message_field(1)
    key: str = betterproto.string_field(2)
    previous_value: bytes = betterproto.bytes_field(3)
    previous_version: int = betterproto.uint64_field(4)
    new_value: bytes = betterproto.bytes_field(5)
    ttl: timedelta = betterproto.message_field(6)


@dataclass
class ReplaceResponse(betterproto.Message):
    header: headers.ResponseHeader = betterproto.message_field(1)
    status: "ResponseStatus" = betterproto.enum_field(2)
    created: datetime = betterproto.message_field(3)
    updated: datetime = betterproto.message_field(4)
    previous_value: bytes = betterproto.bytes_field(5)
    previous_version: int = betterproto.uint64_field(6)


@dataclass
class GetRequest(betterproto.Message):
    header: headers.RequestHeader = betterproto.message_field(1)
    key: str = betterproto.string_field(2)


@dataclass
class GetResponse(betterproto.Message):
    header: headers.ResponseHeader = betterproto.message_field(1)
    value: bytes = betterproto.bytes_field(2)
    version: int = betterproto.uint64_field(3)
    created: datetime = betterproto.message_field(4)
    updated: datetime = betterproto.message_field(5)


@dataclass
class RemoveRequest(betterproto.Message):
    header: headers.RequestHeader = betterproto.message_field(1)
    key: str = betterproto.string_field(2)
    value: bytes = betterproto.bytes_field(3)
    version: int = betterproto.uint64_field(4)
    created: datetime = betterproto.message_field(5)
    updated: datetime = betterproto.message_field(6)


@dataclass
class RemoveResponse(betterproto.Message):
    header: headers.ResponseHeader = betterproto.message_field(1)
    status: "ResponseStatus" = betterproto.enum_field(2)
    previous_value: bytes = betterproto.bytes_field(3)
    previous_version: int = betterproto.uint64_field(4)


@dataclass
class ClearRequest(betterproto.Message):
    header: headers.RequestHeader = betterproto.message_field(1)


@dataclass
class ClearResponse(betterproto.Message):
    header: headers.ResponseHeader = betterproto.message_field(1)


@dataclass
class EntriesRequest(betterproto.Message):
    header: headers.RequestHeader = betterproto.message_field(1)


@dataclass
class EntriesResponse(betterproto.Message):
    header: headers.ResponseHeader = betterproto.message_field(1)
    key: str = betterproto.string_field(2)
    value: bytes = betterproto.bytes_field(3)
    version: int = betterproto.uint64_field(4)
    created: datetime = betterproto.message_field(5)
    updated: datetime = betterproto.message_field(6)


@dataclass
class EventRequest(betterproto.Message):
    header: headers.RequestHeader = betterproto.message_field(1)
    replay: bool = betterproto.bool_field(2)
    key: str = betterproto.string_field(3)


@dataclass
class EventResponse(betterproto.Message):
    header: headers.ResponseHeader = betterproto.message_field(1)
    type: "EventResponseType" = betterproto.enum_field(2)
    key: str = betterproto.string_field(3)
    value: bytes = betterproto.bytes_field(4)
    version: int = betterproto.uint64_field(5)
    created: datetime = betterproto.message_field(6)
    updated: datetime = betterproto.message_field(7)


class MapServiceStub(betterproto.ServiceStub):
    """MapService implements a distributed map"""

    async def create(
        self, *, header: Optional[headers.RequestHeader] = None
    ) -> CreateResponse:
        """Create creates an indexed map"""

        request = CreateRequest()
        if header is not None:
            request.header = header

        return await self._unary_unary(
            "/atomix.map.MapService/Create", request, CreateResponse,
        )

    async def close(
        self, *, header: Optional[headers.RequestHeader] = None, delete: bool = False
    ) -> CloseResponse:
        """Close closes an indexed map"""

        request = CloseRequest()
        if header is not None:
            request.header = header
        request.delete = delete

        return await self._unary_unary(
            "/atomix.map.MapService/Close", request, CloseResponse,
        )

    async def size(
        self, *, header: Optional[headers.RequestHeader] = None
    ) -> SizeResponse:
        """Size returns the size of the map"""

        request = SizeRequest()
        if header is not None:
            request.header = header

        return await self._unary_unary(
            "/atomix.map.MapService/Size", request, SizeResponse,
        )

    async def exists(
        self, *, header: Optional[headers.RequestHeader] = None, key: str = ""
    ) -> ExistsResponse:
        """Exists checks whether a key exists in the map"""

        request = ExistsRequest()
        if header is not None:
            request.header = header
        request.key = key

        return await self._unary_unary(
            "/atomix.map.MapService/Exists", request, ExistsResponse,
        )

    async def put(
        self,
        *,
        header: Optional[headers.RequestHeader] = None,
        key: str = "",
        value: bytes = b"",
        version: int = 0,
        if_empty: bool = False,
        ttl: Optional[timedelta] = None,
    ) -> PutResponse:
        """Put puts an entry into the map"""

        request = PutRequest()
        if header is not None:
            request.header = header
        request.key = key
        request.value = value
        request.version = version
        request.if_empty = if_empty
        if ttl is not None:
            request.ttl = ttl

        return await self._unary_unary(
            "/atomix.map.MapService/Put", request, PutResponse,
        )

    async def replace(
        self,
        *,
        header: Optional[headers.RequestHeader] = None,
        key: str = "",
        previous_value: bytes = b"",
        previous_version: int = 0,
        new_value: bytes = b"",
        ttl: Optional[timedelta] = None,
    ) -> ReplaceResponse:
        """
        Replace performs a check-and-set operation on an entry in the map
        """

        request = ReplaceRequest()
        if header is not None:
            request.header = header
        request.key = key
        request.previous_value = previous_value
        request.previous_version = previous_version
        request.new_value = new_value
        if ttl is not None:
            request.ttl = ttl

        return await self._unary_unary(
            "/atomix.map.MapService/Replace", request, ReplaceResponse,
        )

    async def get(
        self, *, header: Optional[headers.RequestHeader] = None, key: str = ""
    ) -> GetResponse:
        """Get gets the entry for a key"""

        request = GetRequest()
        if header is not None:
            request.header = header
        request.key = key

        return await self._unary_unary(
            "/atomix.map.MapService/Get", request, GetResponse,
        )

    async def remove(
        self,
        *,
        header: Optional[headers.RequestHeader] = None,
        key: str = "",
        value: bytes = b"",
        version: int = 0,
        created: Optional[datetime] = None,
        updated: Optional[datetime] = None,
    ) -> RemoveResponse:
        """Remove removes an entry from the map"""

        request = RemoveRequest()
        if header is not None:
            request.header = header
        request.key = key
        request.value = value
        request.version = version
        if created is not None:
            request.created = created
        if updated is not None:
            request.updated = updated

        return await self._unary_unary(
            "/atomix.map.MapService/Remove", request, RemoveResponse,
        )

    async def clear(
        self, *, header: Optional[headers.RequestHeader] = None
    ) -> ClearResponse:
        """Clear removes all entries from the map"""

        request = ClearRequest()
        if header is not None:
            request.header = header

        return await self._unary_unary(
            "/atomix.map.MapService/Clear", request, ClearResponse,
        )

    async def events(
        self,
        *,
        header: Optional[headers.RequestHeader] = None,
        replay: bool = False,
        key: str = "",
    ) -> AsyncGenerator[EventResponse, None]:
        """Events listens for change events"""

        request = EventRequest()
        if header is not None:
            request.header = header
        request.replay = replay
        request.key = key

        async for response in self._unary_stream(
            "/atomix.map.MapService/Events", request, EventResponse,
        ):
            yield response

    async def entries(
        self, *, header: Optional[headers.RequestHeader] = None
    ) -> AsyncGenerator[EntriesResponse, None]:
        """Entries lists all entries in the map"""

        request = EntriesRequest()
        if header is not None:
            request.header = header

        async for response in self._unary_stream(
            "/atomix.map.MapService/Entries", request, EntriesResponse,
        ):
            yield response
