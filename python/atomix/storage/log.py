# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: atomix/storage/log/log.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import AsyncGenerator, Optional

import betterproto
import grpclib

from .atomix import storage


class ResponseStatus(betterproto.Enum):
    OK = 0
    NOOP = 1
    WRITE_LOCK = 2
    PRECONDITION_FAILED = 3


class EventResponseType(betterproto.Enum):
    NONE = 0
    APPENDED = 1
    REMOVED = 2


@dataclass
class CreateRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)


@dataclass
class CreateResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)


@dataclass
class CloseRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)
    delete: bool = betterproto.bool_field(2)


@dataclass
class CloseResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)


@dataclass
class ExistsRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)


@dataclass
class ExistsResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)
    contains_index: bool = betterproto.bool_field(2)


@dataclass
class SizeRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)


@dataclass
class SizeResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)
    size: int = betterproto.int32_field(2)


@dataclass
class AppendRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)
    value: bytes = betterproto.bytes_field(3)


@dataclass
class AppendResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)
    status: "ResponseStatus" = betterproto.enum_field(2)
    index: int = betterproto.uint64_field(3)
    timestamp: datetime = betterproto.message_field(4)


@dataclass
class GetRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)


@dataclass
class GetResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)
    value: bytes = betterproto.bytes_field(3)
    timestamp: datetime = betterproto.message_field(5)


@dataclass
class FirstEntryRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)


@dataclass
class FirstEntryResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)
    value: bytes = betterproto.bytes_field(3)
    timestamp: datetime = betterproto.message_field(4)


@dataclass
class LastEntryRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)


@dataclass
class LastEntryResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)
    value: bytes = betterproto.bytes_field(3)
    timestamp: datetime = betterproto.message_field(4)


@dataclass
class PrevEntryRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)


@dataclass
class PrevEntryResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)
    value: bytes = betterproto.bytes_field(3)
    timestamp: datetime = betterproto.message_field(4)


@dataclass
class NextEntryRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)


@dataclass
class NextEntryResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)
    value: bytes = betterproto.bytes_field(3)
    timestamp: datetime = betterproto.message_field(4)


@dataclass
class RemoveRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)
    value: bytes = betterproto.bytes_field(3)
    timestamp: datetime = betterproto.message_field(4)


@dataclass
class RemoveResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)
    status: "ResponseStatus" = betterproto.enum_field(2)
    index: int = betterproto.uint64_field(3)
    previous_value: bytes = betterproto.bytes_field(4)


@dataclass
class ClearRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)


@dataclass
class ClearResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)


@dataclass
class EntriesRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)


@dataclass
class EntriesResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)
    index: int = betterproto.uint64_field(2)
    value: bytes = betterproto.bytes_field(3)
    timestamp: datetime = betterproto.message_field(4)


@dataclass
class EventRequest(betterproto.Message):
    header: storage.RequestHeader = betterproto.message_field(1)
    replay: bool = betterproto.bool_field(2)
    index: int = betterproto.uint64_field(3)


@dataclass
class EventResponse(betterproto.Message):
    header: storage.ResponseHeader = betterproto.message_field(1)
    type: "EventResponseType" = betterproto.enum_field(2)
    index: int = betterproto.uint64_field(3)
    value: bytes = betterproto.bytes_field(4)
    timestamp: datetime = betterproto.message_field(5)


class LogServiceStub(betterproto.ServiceStub):
    """LogService log service"""

    async def create(
        self, *, header: Optional[storage.RequestHeader] = None
    ) -> CreateResponse:
        """Create creates a log"""

        request = CreateRequest()
        if header is not None:
            request.header = header

        return await self._unary_unary(
            "/atomix.storage.log.LogService/Create", request, CreateResponse,
        )

    async def close(
        self, *, header: Optional[storage.RequestHeader] = None, delete: bool = False
    ) -> CloseResponse:
        """Close closes a log"""

        request = CloseRequest()
        if header is not None:
            request.header = header
        request.delete = delete

        return await self._unary_unary(
            "/atomix.storage.log.LogService/Close", request, CloseResponse,
        )

    async def size(
        self, *, header: Optional[storage.RequestHeader] = None
    ) -> SizeResponse:
        """Size returns the size of the log"""

        request = SizeRequest()
        if header is not None:
            request.header = header

        return await self._unary_unary(
            "/atomix.storage.log.LogService/Size", request, SizeResponse,
        )

    async def exists(
        self, *, header: Optional[storage.RequestHeader] = None, index: int = 0
    ) -> ExistsResponse:
        """Exists checks whether an index exists in the log"""

        request = ExistsRequest()
        if header is not None:
            request.header = header
        request.index = index

        return await self._unary_unary(
            "/atomix.storage.log.LogService/Exists", request, ExistsResponse,
        )

    async def append(
        self,
        *,
        header: Optional[storage.RequestHeader] = None,
        index: int = 0,
        value: bytes = b"",
    ) -> AppendResponse:
        """Appends appends an entry into the log"""

        request = AppendRequest()
        if header is not None:
            request.header = header
        request.index = index
        request.value = value

        return await self._unary_unary(
            "/atomix.storage.log.LogService/Append", request, AppendResponse,
        )

    async def get(
        self, *, header: Optional[storage.RequestHeader] = None, index: int = 0
    ) -> GetResponse:
        """Get gets the entry for an index"""

        request = GetRequest()
        if header is not None:
            request.header = header
        request.index = index

        return await self._unary_unary(
            "/atomix.storage.log.LogService/Get", request, GetResponse,
        )

    async def first_entry(
        self, *, header: Optional[storage.RequestHeader] = None
    ) -> FirstEntryResponse:
        """FirstEntry gets the first entry in the log"""

        request = FirstEntryRequest()
        if header is not None:
            request.header = header

        return await self._unary_unary(
            "/atomix.storage.log.LogService/FirstEntry", request, FirstEntryResponse,
        )

    async def last_entry(
        self, *, header: Optional[storage.RequestHeader] = None
    ) -> LastEntryResponse:
        """LastEntry gets the last entry in the log"""

        request = LastEntryRequest()
        if header is not None:
            request.header = header

        return await self._unary_unary(
            "/atomix.storage.log.LogService/LastEntry", request, LastEntryResponse,
        )

    async def prev_entry(
        self, *, header: Optional[storage.RequestHeader] = None, index: int = 0
    ) -> PrevEntryResponse:
        """PrevEntry gets the previous entry in the log"""

        request = PrevEntryRequest()
        if header is not None:
            request.header = header
        request.index = index

        return await self._unary_unary(
            "/atomix.storage.log.LogService/PrevEntry", request, PrevEntryResponse,
        )

    async def next_entry(
        self, *, header: Optional[storage.RequestHeader] = None, index: int = 0
    ) -> NextEntryResponse:
        """NextEntry gets the next entry in the log"""

        request = NextEntryRequest()
        if header is not None:
            request.header = header
        request.index = index

        return await self._unary_unary(
            "/atomix.storage.log.LogService/NextEntry", request, NextEntryResponse,
        )

    async def remove(
        self,
        *,
        header: Optional[storage.RequestHeader] = None,
        index: int = 0,
        value: bytes = b"",
        timestamp: Optional[datetime] = None,
    ) -> RemoveResponse:
        """Remove removes an entry from the log"""

        request = RemoveRequest()
        if header is not None:
            request.header = header
        request.index = index
        request.value = value
        if timestamp is not None:
            request.timestamp = timestamp

        return await self._unary_unary(
            "/atomix.storage.log.LogService/Remove", request, RemoveResponse,
        )

    async def clear(
        self, *, header: Optional[storage.RequestHeader] = None
    ) -> ClearResponse:
        """Clear removes all entries from the log"""

        request = ClearRequest()
        if header is not None:
            request.header = header

        return await self._unary_unary(
            "/atomix.storage.log.LogService/Clear", request, ClearResponse,
        )

    async def events(
        self,
        *,
        header: Optional[storage.RequestHeader] = None,
        replay: bool = False,
        index: int = 0,
    ) -> AsyncGenerator[EventResponse, None]:
        """Events listens for change events"""

        request = EventRequest()
        if header is not None:
            request.header = header
        request.replay = replay
        request.index = index

        async for response in self._unary_stream(
            "/atomix.storage.log.LogService/Events", request, EventResponse,
        ):
            yield response

    async def entries(
        self, *, header: Optional[storage.RequestHeader] = None
    ) -> AsyncGenerator[EntriesResponse, None]:
        """Entries lists all entries in the log"""

        request = EntriesRequest()
        if header is not None:
            request.header = header

        async for response in self._unary_stream(
            "/atomix.storage.log.LogService/Entries", request, EntriesResponse,
        ):
            yield response
